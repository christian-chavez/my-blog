import * as React from 'react';
import { useReducer, useMemo, useContext, useEffect } from 'react';

const isAtom = (recoilValue) => Object.keys(recoilValue).includes("default");

const coilStores = {};
const getCoilStore = (coilId) => {
    coilStores[coilId] = coilStores[coilId] || {};
    return coilStores[coilId];
};
const currentCoilId = 0;
const generateCoilId = () => (currentCoilId + 1).toString();
const coreGetAtomValue = (coilId, atom) => {
    const coreCoilValue = getCoilStore(coilId)[atom.key];
    if (coreCoilValue.type !== "atom") {
        throw new Error(`${coreCoilValue.key} is not an atom`);
    }
    return coreCoilValue.value;
};
const coreGetSelectorValue = (coilId, selector) => selector.get({ get: createPublicGetCoilValue(coilId) });
const coreGetCoilValue = (coilId, coilValue) => isAtom(coilValue)
    ? coreGetAtomValue(coilId, coilValue)
    : coreGetSelectorValue(coilId, coilValue);
const createPublicGetCoilValue = (coilId) => (coilValue) => coreGetCoilValue(coilId, coilValue);
const createPublicSetAtomValue = (coilId, coilValue) => (nextValue) => coreSetAtomValue(coilId, coilValue, nextValue);
const coreSetAtomValue = (coilId, coilValue, nextValue) => {
    const coreCoilValue = getCoilStore(coilId)[coilValue.key];
    if (coreCoilValue.type !== "atom") {
        throw new Error(`${coreCoilValue.key} is not an atom`);
    }
    if (nextValue !== coreCoilValue.value) {
        coreCoilValue.value = nextValue;
        coreCoilValue.subscribers.forEach(callback => callback());
    }
};
const createPublicSetCoilValue = (coilId) => (coilValue, nextValue) => coreSetCoilValue(coilId, coilValue, nextValue);
const coreSetCoilValue = (coilId, coilValue, nextValue) => {
    if (isAtom(coilValue)) {
        coreSetAtomValue(coilId, coilValue, nextValue);
    }
    else if (coilValue.set) {
        coilValue.set({
            get: createPublicGetCoilValue(coilId),
            set: createPublicSetCoilValue(coilId),
        }, nextValue);
    }
};
const registerCoilValue = (coilId, coilValue) => {
    const { key } = coilValue;
    const coilStore = getCoilStore(coilId);
    if (coilStore[key]) {
        return;
    }
    if (isAtom(coilValue)) {
        coilStore[key] = {
            default: coilValue.default,
            key,
            subscribers: [],
            type: "atom",
            value: coilValue.default,
        };
    }
    else {
        coilStore[key] = {
            key,
            subscribers: [],
            type: "selector",
        };
    }
};
const subscribeToCoilValueUpdates = (coilId, key, callback) => {
    const coilValue = getCoilStore(coilId)[key];
    const { subscribers } = coilValue;
    if (subscribers.includes(callback)) {
        throw new Error("Already subscribed to Coil Value");
    }
    subscribers.push(callback);
    return () => {
        subscribers.splice(subscribers.indexOf(callback), 1);
    };
};

const CoilContext = React.createContext("");
const CoilProvider = (props) => {
    const { children } = props;
    const id = generateCoilId();
    return React.createElement(CoilContext.Provider, { value: id }, children);
};

const atom = (a) => a;
const selector = (s) => s;
const useCoilId = () => {
    const coilId = useContext(CoilContext);
    if (!coilId) {
        throw new Error("Wrap your app with <CoilRoot>");
    }
    return coilId;
};
const createDependenciesSpy = (coilId, dependencies) => {
    const dependenciesSpy = (coilValue) => {
        dependencies.push(coilValue.key);
        if (isAtom(coilValue)) {
            return coreGetCoilValue(coilId, coilValue);
        }
        return coilValue.get({ get: dependenciesSpy });
    };
    return dependenciesSpy;
};
const useSubscribeToCoilValues = (coilValue, callback) => {
    const coilId = useCoilId();
    useEffect(() => {
        if (isAtom(coilValue)) {
            return subscribeToCoilValueUpdates(coilId, coilValue.key, callback);
        }
        const dependencies = [];
        coilValue.get({ get: createDependenciesSpy(coilId, dependencies) });
        const unsubscribes = [];
        dependencies.forEach(key => unsubscribes.push(subscribeToCoilValueUpdates(coilId, key, callback)));
        return () => unsubscribes.forEach(unsubscribe => unsubscribe());
    }, [coilId, coilValue, callback]);
};
const useCoilValue = (coilValue) => {
    const coilId = useCoilId();
    const [, forceRender] = useReducer(s => s + 1, 0);
    registerCoilValue(coilId, coilValue);
    useSubscribeToCoilValues(coilValue, forceRender);
    return coreGetCoilValue(coilId, coilValue);
};
const useCoilState = (coilValue) => {
    const coilId = useCoilId();
    const currentValue = useCoilValue(coilValue);
    const setter = useMemo(() => {
        if (isAtom(coilValue)) {
            return createPublicSetAtomValue(coilId, coilValue);
        }
        return (nextValue) => {
            if (coilValue.set)
                coilValue.set({
                    get: createPublicGetCoilValue(coilId),
                    set: createPublicSetCoilValue(coilId),
                }, nextValue);
        };
    }, [coilId, coilValue]);
    return [currentValue, setter];
};

export { CoilContext, CoilProvider, atom, isAtom, selector, useCoilState, useCoilValue };
//# sourceMappingURL=diesel.es5.js.map
